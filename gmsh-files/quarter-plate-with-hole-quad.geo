R = 0.3;%定义半径R为0.3
L = 1.0;%定义长度L为1.0

Point(1) = {L, -L, 0};%% 定义点1位于(1.0, -1.0, 0)
Point(2) = {L, L, 0};% 定义点2位于(1.0, 1.0, 0)
Point(3) = {-L, L, 0};% 定义点3位于(-1.0, 1.0, 0)
Point(4) = {-L, -L, 0};% 定义点4位于(-1.0, -1.0, 0)
Point(5) = {-L + R, -L, 0};% 定义点5位于(-0.7, -1.0, 0)
Point(6) = {-L, -L + R, 0};% 定义点6位于(-1.0, -0.7, 0)
Point(7) = {-L + Cos(Pi/4) * R, -L + Sin(Pi/4) * R, 0};% 定义点7位于(-0.866, -0.866, 0)，根据极坐标计算的点坐标，位于圆弧中点

Circle(1) = {5, 4, 7};%圆弧1连接点5和7，以4为圆心
Circle(2) = {7, 4, 6};%圆弧1连接点6和7，以4为圆心

Line(3) = {6, 3}; % 直线3连接点6和3
Line(4) = {3, 2}; % 直线4连接点3和2
Line(5) = {2, 1}; % 直线5连接点2和1
Line(6) = {1, 5}; % 直线6连接点1和5
Line(7) = {2, 7}; % 直线7连接点2和7

Curve Loop(1) = {4, 7, 2, 3};%第一个区域由直线4,7,3，和八分之一圆弧2组成
Plane Surface(1) = {1};%第一个区域（平面）

Curve Loop(2) = {7, -1, -6, -5};% 曲线环2包含圆弧7、直线-1（反向的圆弧1）、直线-6和-5（反向的直线6和5）
Plane Surface(2) = {2};% 平面2由曲线环2生成

Transfinite Line{1, 2, 3, 4, 5, 6, 7} = 3;% 将所有线段的网格大小设置为3

Transfinite Surface{1};% 平面1的网格大小自动计算，于指定表面n上的网格应该是无限的，
%即没有内部节点。这通常用于边界表面，意味着在这些表面上生成的网格将不会有内部节点，只有边界节点。
%这对于边界条件的应用非常有用，比如在流体分析中，你可能希望在边界上应用无滑移条件，而不需要在边界内部有任何节点。
Transfinite Surface{2}; % 平面2的网格大小自动计算

Recombine Surface{1}; % 平面1的网格重新组合，命令用于优化表面n上的网格。这个命令会尝试重新组合和优化表面的网格，
%以减少网格数量并提高网格质量。这通常会导致更平滑的表面网格，减少元素扭曲，并可能提高有限元分析的精度和效率。
Recombine Surface{2}; % 平面2的网格重新组合

Mesh.ElementOrder = 1; % 网格元素的阶数为1（线性元素），设置网格元素的阶数为1，这意味着生成的网格将使用线性元素。
线性元素是最简单的网格元素，它们在每个维度上都是直的，例如，线性三角形或线性四边形。
这种类型的网格对于简单的分析或者当不需要高阶精度时是足够的。
Mesh.Algorithm = 8; % 使用算法8进行网格生成， 指定网格生成算法。
在Gmsh中，算法8是“Delaire算法”，它是一种用于生成高质量网格的算法，特别适用于复杂几何形状。
Delaire算法能够生成具有较好形状和大小分布的网格，并且可以处理包括六面体、五面体和四面体在内的多种类型的元素。
这个算法特别适合于需要高质量网格的复杂模型，以确保有限元分析的准确性和收敛性。

// EOF
